# üìä Analisador de Desempenho de Algoritmos de Ordena√ß√£o em C

![Linguagem](https://img.shields.io/badge/Linguagem-C-blue.svg)

## üìñ Sobre o Projeto

Este projeto √© uma ferramenta desenvolvida em linguagem C para analisar e comparar o desempenho de alguns dos algoritmos de ordena√ß√£o mais conhecidos. O programa gera um array de tamanho customiz√°vel com valores aleat√≥rios e executa cada algoritmo de ordena√ß√£o sobre o mesmo array desordenado, medindo o tempo de execu√ß√£o de cada um dos algoritmos.

O principal objetivo √© demonstrar visualmente as diferen√ßas de efici√™ncia te√≥ricas (expressas pela nota√ß√£o Big O) em um cen√°rio pr√°tico.

## ‚ú® Funcionalidades

- **Implementa√ß√£o de M√∫ltiplos Algoritmos:** Inclui algoritmos com complexidades de $O(n^2)$, $O(n \log n)$ e $O(n+k)$.
- **An√°lise de Desempenho:** Mede o tempo que cada algoritmo leva para ordenar o conjunto de dados.
- **Entrada do Usu√°rio:** Permite que o usu√°rio defina o tamanho do array a ser testado.
- **Compara√ß√£o Justa:** Garante que todos os algoritmos sejam testados sob as mesmas condi√ß√µes, utilizando uma c√≥pia id√™ntica do array desordenado original.

## üöÄ Algoritmos Implementados

| Algoritmo | Complexidade (M√©dio) | Complexidade (Pior Caso) | Espa√ßo |
| :--- | :---: | :---: | :---: |
| **Bubble Sort** | $O(n^2)$ | $O(n^2)$ | $O(1)$ |
| **Selection Sort** | $O(n^2)$ | $O(n^2)$ | $O(1)$ |
| **Insertion Sort** | $O(n^2)$ | $O(n^2)$ | $O(1)$ |
| **Quick Sort** | $O(n \log n)$ | $O(n^2)$ | $O(\log n)$ |
| **Merge Sort** | $O(n \log n)$ | $O(n \log n)$ | $O(n)$ |
| **Counting Sort** | $O(n+k)$ | $O(n+k)$ | $O(k)$ |

*Onde `n` √© o n√∫mero de elementos e `k` √© o intervalo dos valores.*

## ‚öôÔ∏è Como Executar

Para compilar e executar este projeto, voc√™ precisar√° de um compilador C, como o GCC.

1.  **Clone o reposit√≥rio:**
    ```bash
    git clone https://github.com/FernandoFrareVieira/analisador-algoritmos-ordenacao.git
    cd analisador-algoritmos-ordenacao
    ```

2.  **Compile o arquivo:**
    ```bash
    gcc -o analisador main.c sorting.c
    ```
    *Se voc√™ separar os arquivos como sugerido abaixo, o comando ser√°: `gcc -o analisador main.c sorting.c -WAll`*

3.  **Execute o programa:**
    ```bash
    ./analisador
    ```
    O programa solicitar√° que voc√™ digite o tamanho do array para o teste.

## üìà Resultados de Desempenho

Os testes abaixo foram executados para ordenar um array de **50.000 elementos** com valores aleat√≥rios.

| Algoritmo | Tempo de Execu√ß√£o (s) |
| :--- | :---: |
| Bubble Sort | 13.531000 |
| Selection Sort | 3.659000 |
| Insertion Sort | 2.156000 |
| Quick Sort | 0.007000 |
| Merge Sort | 0.031000 |
| Counting Sort | 0.001000 |

### An√°lise dos Resultados

Os resultados demonstram claramente a superioridade dos algoritmos mais eficientes:

-   Os algoritmos de complexidade quadr√°tica ($O(n^2)$), como Bubble Sort, Selection Sort e Insertion Sort, s√£o significativamente mais lentos e se tornam invi√°veis para conjuntos de dados maiores.
-   Quick Sort e Merge Sort, com complexidade $O(n \log n)$, apresentam um desempenho ordens de magnitude melhor, sendo excelentes para casos de uso gerais.
-   O Counting Sort, um algoritmo n√£o baseado em compara√ß√µes, mostra-se o mais r√°pido de todos. Isso se deve √† sua complexidade linear ($O(n+k)$), que √© extremamente eficiente quando o intervalo de valores (`k`) n√£o √© muito maior que o n√∫mero de elementos do vetor senndo ordenado.